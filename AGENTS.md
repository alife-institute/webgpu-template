# Project-specific AI guidance

## Build and Development Workflow

### Build Process

This project uses Webpack to build TypeScript and WGSL shaders into a static HTML application:

```bash
npm run build    # Build to dist/
```

**Important**: The final output is a **static HTML file** at `dist/index.html`, along with bundled JavaScript.

### File Structure

```
src/
├── index.ts              # Main entry point
├── utils.ts              # WebGPU utilities (includes setupTextures helper)
├── index.html            # HTML template (processed by webpack)
├── assets/               # Static assets (images, etc.)
└── shaders/
    ├── compute.wgsl      # Compute shader
    ├── render.wgsl       # Render shader (vertex + fragment)
    └── includes/         # Shared WGSL code (imported via #import)
        ├── bindings.wgsl # Binding layout definitions (single source of truth)
        └── textures.wgsl # Texture declarations (shared across shaders)

dist/                     # Built output (generated by webpack)
├── index.html            # Final HTML (includes bundled scripts)
├── index.bundle.js       # Bundled application code
└── runtime.bundle.js     # Webpack runtime
```

## Testing and Validation

### Automated Capture Tool

After making code changes, use the capture tool to verify the simulation works:

```bash
npm run build
npm run capture
```

Check `.capture/session-[timestamp]/` for results
**What gets captured**:

- Console output (logs, warnings, errors)
- Multiple screenshots showing animation over time
- JSON summary with error analysis

**Output location**: `.capture/session-[timestamp]/`

### When to Use Capture Tool

**Always capture after**:

- Modifying shaders (compute.wgsl, render.wgsl)
- Changing simulation logic (index.ts)
- Updating WebGPU initialization (utils.ts)
- Making any code changes that affect rendering

**Why**: The capture tool runs in a real Chrome browser with WebGPU support, catching:

- Shader compilation errors
- WebGPU API usage errors
- Runtime errors that don't show up during build
- Visual verification that the simulation actually renders

### Expected Console Output

A healthy simulation should show:

```
✓ [INFO] [webpack-dev-server] Server started...
✓ [LOG] [HMR] Waiting for update signal from WDS...
✓ [INFO] WebGPU is experimental on this platform...
```

**Common errors to watch for**:

- `Failed to load resource: 404` - Wrong URL or missing file
- `Shader compilation failed` - WGSL syntax errors
- `WebGPU not supported` - Browser compatibility issue
- `TypeError` - JavaScript errors in your code

### WebGPU Screenshot and Console Capture

**The capture tool opens a visible browser by default** so WebGPU screenshots work correctly:

- Opens `dist/index.html` directly using `file://` protocol
- No dev server needed
- Screenshots capture the actual rendered output
- Console logs are also captured for debugging

**Note**: WebGPU does not render in headless Chrome, so screenshots would be black in headless mode. The default non-headless mode ensures screenshots work out of the box.

### Verifying Captures

```bash
# Check console logs for errors
cat .capture/session-*/console.log

# View error summary as JSON
jq '.errors' .capture/session-*/summary.json

# View screenshots (in any image viewer)
open .capture/session-*/frame-0002.png
```

### Development Server

This is typically used by human for debugging sessions and visualising hot-reloaded code changes

```bash
npm start # hot-reload on localhost:5500
```

**Do NOT run `npm start`** - The development server is for human interactive debugging and visualization only. The capture tool provides everything needed for automated validation.

## Architecture Principles

### Includes System for Shared WGSL Code

The template uses a custom `#import` system to eliminate duplication and maintain a single source of truth:

**How it works**:
1. **Define once** in `src/shaders/includes/bindings.wgsl` - Binding indices and layout structures
2. **Declare once** in `src/shaders/includes/textures.wgsl` - Texture variables with their bindings
3. **Import everywhere** using `#import includes::bindings` and `#import includes::textures`

**Benefits**:
- **No duplication**: Binding indices defined once, used everywhere
- **Type safety**: WGSL structures ensure consistency between TS and shaders
- **Easy refactoring**: Change binding index in one place, updates everywhere
- **Clear contracts**: The includes files document the full binding interface

**Example workflow**:
```wgsl
// In compute.wgsl or render.wgsl
#import includes::bindings  // Gets BINDINGS constants
#import includes::textures  // Gets texture variable declarations

// Now you can use: states, velocities, etc.
let value = textureLoad(states, pos, 0);
```

### setupTextures Utility Simplifies Texture Management

The `setupTextures()` function in `utils.ts` automates texture creation, data upload, and binding layout setup:

**What it handles automatically**:
- Creates GPU textures with correct usage flags (`STORAGE_BINDING | TEXTURE_BINDING | COPY_DST`)
- Initializes textures with provided data or zeros
- Configures 2D vs 2D-array based on `depthOrArrayLayers` parameter
- Sets up binding layouts for bind groups
- Handles multi-channel formats (r32float, rg32float, rgba32float, r32uint, etc.)
- Creates canvas size buffer for shader access to dimensions

**How to add a new texture**:
1. Update `src/shaders/includes/bindings.wgsl` with new binding index
2. Update `src/shaders/includes/textures.wgsl` with new texture declaration
3. Update TypeScript `BINDINGS` object in `src/index.ts`
4. Add texture to `setupTextures()` call with initial data, layers, and format

**No manual bind group layout creation needed** - the utility generates everything from your configuration.

## Coding practices

### General

- Self-documenting code. Prefer clear naming of variables and functions. In most cases the logic of the program is evident from control flow and variable names so **do NOT comment code** unless absolutely necessary.

### WebGPU

- Prefer using `texture_2d_array` for multiple simulation layers
- Use the includes system for all binding definitions - no hardcoded binding indices
- Use `setupTextures()` utility for texture creation - handles all boilerplate automatically
